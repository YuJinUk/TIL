# 2_20

# Queue

- queue의 특성
  
  - stack과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  
  - queue의 뒤에서는 삽입만 하고, queue의 앞에서는 삭제만 이루어지는 구조

- FIFO(first in first out)
  
  - queue에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.

- 연산
  
  - 삽입 : enQueue(item) : queue의 뒤쪽(rear)에 원소를 삽입하는 연산
  
  - 삭제 : deQueue : queue의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
  
  - 머리 : Front 
  
  - 꼬리 : Rear
  
  - createQueue() : 공백 상태의 queue를 생성하는 연산
  
  - isEmpty() : queue가 공백상태인지를 확인하는 연산
  
  - isFull() : queue가 포화상태인지를 확인하는 연산
  
  - Qpeek() : queue의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산

- linear queue
  
  - 1차원 배열을 이용한 queue
    
    - queue의 size == 배열의 size
    
    - front : 저장된 첫 번째 원소의 index
    
    - rear : 저장된 마지막 원소의 index
  
  - 상태 표현
    
    - 초기 : front == rear == -1
    
    - 공백 : front == rear
    
    - 포화 : rear == n - 1 (n : 배열의 size)

- 삽입 : enQueue(item)
  
  - 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
    
    1) rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
    
    2) 그 index에 해당하는 배열원소 Q[rear]에 item을 저장
    
    ```python
    def enQueue(item):
        global rear
        if isFull() : print("Queue_Full")
        else:
            rear += 1
            Q[rear] = item
    ```

- 삭제 : deQueue(item)
  
  - 가장 앞에 있는 원소를 삭제하기 위해
    
    1) front 값을 하나 증가시켜 큐에 남아있게 될 첫 번째 원소 이동
    
    2) 새로운 첫 번째 원소를 리턴함으로써 삭제와 동일한 기능함
    
    ```python
    def deQueue():
        global front
        if isEmpty : print("Queue_Empty")
        else:
            front += 1
            return Q[front]
    ```

- 공백상태 및 포화상태 검사 : isEmpty(), isFull()
  
  - 공백상태 : front == rear
  
  - 포화상태 : rear == n-1 (n : 배열의 크기)
  
  ```python
  def isEmpty():
      return front == rear
  def isFull():
      return rear == len(Queue) - 1
  ```

- 검색 : Qpeek()
  
  - 가장 앞에 있는 원소를 검색하여 반환하는 연산
  
  - 현재 front의 한자리 뒤(front + 1)에 있는 원소, 즉 queue의 첫 번째에 있는 원소를 반환
  
  ```python
  def Qpeek():
      if isEmpty(): print("Queue_Empty")
      else : return Q[front + 1]
  ```










