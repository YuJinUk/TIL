# 1_19

### 함수 응용

> 내장 함수(Built-in Functions)
> 
> - 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 type이 내장되어 있음
>   
>   ![화면 캡처 2023-01-19 090019.png](${hello}_assets/ac302d15e889a0f85a954cb81f97ae20f455b564.png)

> map(function, iterable)
> 
> - 순회 가능한 데이터 구조(iterable)의 모든 요소에 함수(function)를 적용하고, 그 결과를 map object로 반환 > list, set, tuple등으로 형변환 필요
>   
>   ```python
>   n, m = map(int, input().split()) # 3,5를 입력하면
>   print(n, m) # 3,5
>   print(type(n), type(m)) # 둘 다 class가 int로 print됨
>   ```

> filter(function, iterable)
> 
> - 순회 가능한 데이터 구조(iterable)의 모든 요소에 함수(function)를 적용하고, 그 결과가 True인 것들을 filter object로 반환 > list, set, tuple등으로 형변환 필요
>   
>   ```python
>   def odd(n): # 2로 나눈 나머지를 return하는 func
>       return n % 2
>   numbers = [1,2,3] 
>   # num의 원소들을 하나하나 odd에 적용시키고 True인 것만 저장한다. 
>   result = filter(odd, num) 
>   print(result, type(result)) # filter object / class 'filter'
>   print(list(result)) # [1,3]
>   ```

> zip(*iterable)
> 
> - 복수의 iterable을 모아 tuple을 원소로 하는 zip object를 반환
>   
>   ```python
>   girls = ['jane','ashley']
>   boys = ['justin','eric']
>   pair = zip(girls, boys)
>   print(pair, type(pair)) # zip object / class 'zip'
>   print(list(pair)) # [('jane','justin'),('ashely','eirc)]
>   ```

> lambda [parameter] : 표현식
> 
> - 람다 함수
>   
>   - 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명 함수라고도 불림
> 
> - 특징
>   
>   - return문을 가질 수 없음
>   
>   - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
> 
> - 장점
>   
>   - 함수를 정의해서 사용하는 것보다 간결하게 사용 가능
>   
>   - def를 사용할 수 없는 곳에서도 사용 가능
>   
>   ```python
>   # 삼각형의 넓이를 구하는 공식 - def
>   def triangle_area(b,h):
>       return 0.5 * b * h
>   print(triangle_area(5,6)) # 15.0
>   
>   
>   # 삼각형의 넓이를 구하는 공식 - lambda
>   triangle_area = lambda b, h : 0.5 * b * h
>   print(triangle_area(5,6)) # 15.0
>   
>   
>   # lambda와 map을 합쳐 x^2을 구하는 func
>   list(map(lambda x : x ** 2, [1,2,3,4])
>   ```

> 재귀 함수(recursive function)
> 
> - 자기 자신을 호출하는 함수
> 
> - 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용
>   
>   - 알고리즘 중 재귀 함수로 로직을 표현하기 쉬운 경우가 있음(ex) 점화식)
>   
>   - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
> 
> - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성
> 
> - 재귀 함수 예시
>   
>   ```python
>   def factorial(n):
>       if n == 0 or n == 1:
>           return 1
>       else :
>           return n * factorial(n-1)
>   print(factorial(4)) # 24
>   ```
> 
> - 재귀 함수 주의사항
>   
>   - 재귀 함수는 base case에 도달할 때까지 함수를 호출함
>   
>   - 메모리 스택이 넘치게 되면(stack overflow) 프로그램이 동작하지 않게 됨
>   
>   - 파이썬에서는 최대 재귀 깊이(maximum recursion depth)가 1,000번으로, 호출 횟수가 이를 넘어가게 되면 Recursion Error 발생
> 
> - 반복문(for, while)과 재귀 함수 비교
>   
>   - 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수를 사용함.
>   
>   - 재귀 호출은 변수 사용을 줄여줄 수 있음.
>   
>   - 재귀 호출은 입력 값이 커질 수록 연산 속도가 오래 걸림.

### 패킹 / 언패킹 (Packing / Unpacking)

> 패킹 / 언패킹 연산자 (Packing / Unpacking Operator)
> 
> - 모든 시퀀스형(list, tuple 등)은 패킹/언패킹 연산자 *을 사용하여 객체의 패킹 or 언패킹이 가능
>   
>   - ex) x, *y = i,j,k...
> 
> - 패킹
>   
>   - 대입문의 좌변 변수에 위치
>   
>   - 우변의 객체 수가 좌변의 변수 수보다 많을 경우 객체를 순서대로 대입
>   
>   - 나머지 항목들은 모두 별 기호 표시된 변수에 리스트로 대입
>     
>     ex)
>     
>     ```python
>     x, *y = 1, 2, 3, 4
>     print(x, y) # 1, [2,3,4]
>     ```
> 
> - 언패킹
>   
>   - argument 이름이 *로 시작하는 경우, argument unpacking이라 함
>     
>     - *패킹의 경우, 리스트로 대입
>     
>     - *언패킹의 경우 튜플 형태로 대입 
